---
layout:     post
title:      MySql行锁
subtitle:   MySQL行锁，怎样减少行锁对性能的影响？
date:       2019-02-13
author:     tryingpfq
header-img: img/post-mysql-hangsuo.jpg
catalog: true
tags:
    - MySQL
---

## 导读
Mysql的行锁是在引擎层由各个引擎自己实现的，但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。对于不支持行锁，
意味着并发控制就只能使用表锁，对于这种引擎的表，任何时候，只要有一个更新操作，就会影响并发。而InnoDB是支持行锁的，这
也是MySIAM被InnoDB代替的重要原因之一。

## InnoDB行锁
顾名思义，行锁就是对数据表中某行记录进行加锁，比如两个事物要操作同一行记录，后一条记录必须等待前一条完成后才能操作，而且
是在commit后才释放。

### 死锁和死锁检测
  **一旦发生了死锁，就会出现循环等待，那InnoDB是怎么处理的呢？**
  * 1 :一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置，默认是50s,
  这个等待时间是五无法接受的。
  * 2 :另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某个事物，让其他事物得以继续执行。将
  参数innodb_deadlock_detect设置为on，默认开启。（通常采用这种策略，主动检测死锁）

   **如何减少检测死锁时的cpu消耗**
   
死锁检测是要消耗大量的cpu资源，一般遇到这种问题怎么去解决了
可以把一条记录拆分成多条记录进行操作；如果有中间件，可以在中间件实现；如果懂得修改MySQL源码，可以修改源码
对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作了。
   

## 小结
如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请尽量往后放。
但是，调整语句顺序并不能完全避免死锁。


## 问题
如果要删除一个表里面的前10000行数据，有一下三种可以做到，怎么选择
```
 1：delete from T limit 10000;
 2: while(true){
        delete from T limit 500; //循环20次删除
     }
 3：20个连接中同时删除 delete from T limit 500;
```
     
