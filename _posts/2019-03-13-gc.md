---
layout:     post
title:      垃圾回收
subtitle:   垃圾回收器和算法，以及内存分配策略
date:       2019-03-13
author:     tryingpfq
header-img: img/post-bg-gc1.jpg
catalog: true
tags:
    - JVM
---

> 对于来及回收，对于Java程序员来说应该是不陌生的。想要长远的发展，必须对这块机制有所了解，
这样才能写出更高效的代码。如果遇到性能的瓶颈，那么肯定要从这方面去分析，做一些调优。

### 前言
垃圾回收，在Java虚拟机中，垃圾指的是死亡对象所占用的空间，顾明思议就是对内存中已死的对象进行回收，那么如何找出已死的对象，如何进行回收，已近新的对象内存如何分配，
就是垃圾回收要考虑的地方。

### 如何判断对象已死
所谓的对象已死，就是在内存中游离的对象，没有再被用到，但有占用空间，目前主要有两种方法去判断。

#### 引用计数法
这个做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数，每当有一个地方引用它时，计数器+1，当失效后会减1。
一旦该对象的引用计数器为0，则说明该对象已死亡，便可以被回收。

**这种方法会带来一个问题**：除了需要格外的空间来存储引用计数器，以及繁琐的更新操作，还有一个重大漏洞，那就是无法处理循环引用
问题。下面这两个对象是不会被标记会死亡的：
![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-gc1.png?raw=true)

#### 可达性分析
目前Java虚拟机的主流垃圾回收器采取的可达性分析算法。这个算法的实质在于将一系列GC Roots作为初始的存活对象集合（live Set），然后从该集合出发，
探索所有能够被该集合引用的对象，并加入到该集合中，这个过程就是标记过程。最终，未被探索到的对象便是死亡，是可回收的。

那么什么是GC Roots，其实就是由堆外指向堆内的，一般GC Root包括一下几种：
* 1：Java方法栈中的局部变量。
* 2：已加载类的静态变量。
* 3：JNI中引用对象。
* 4：已启动但为停止的Java线程

虽然可达性分析，可以解决循环引用问题，但自身也存在一些问题，比如说，在多线程下，其他线程可能会更新已经访问过的对象中的引用，
从而造成误报（将引用设置为null）或者漏报（将引用设置为未被访问过的对象）。
![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-gc2.png?raw=true)

### 垃圾收集算法


### 垃圾收集器

### 分配策略
