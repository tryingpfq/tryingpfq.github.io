---
layout:     post
title:      垃圾回收
subtitle:   垃圾回收器和算法，以及内存分配策略
date:       2019-03-13
author:     tryingpfq
header-img: img/post-bg-gc1.jpg
catalog: true
tags:
    - JVM
---

> 对于来及回收，对于Java程序员来说应该是不陌生的。想要长远的发展，必须对这块机制有所了解，
这样才能写出更高效的代码。如果遇到性能的瓶颈，那么肯定要从这方面去分析，做一些调优。

### 前言
垃圾回收，在Java虚拟机中，垃圾指的是死亡对象所占用的空间，顾明思议就是对内存中已死的对象进行回收，那么如何找出已死的对象，如何进行回收，已近新的对象内存如何分配，
就是垃圾回收要考虑的地方。

### 如何判断对象已死
所谓的对象已死，就是在内存中游离的对象，没有再被用到，但有占用空间，目前主要有两种方法去判断。

#### 引用计数法
这个做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数，每当有一个地方引用它时，计数器+1，当失效后会减1。
一旦该对象的引用计数器为0，则说明该对象已死亡，便可以被回收。

**这种方法会带来一个问题**：除了需要格外的空间来存储引用计数器，以及繁琐的更新操作，还有一个重大漏洞，那就是无法处理循环引用
问题。下面这两个对象是不会被标记会死亡的：
![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-gc1.png?raw=true)

#### 可达性分析
目前Java虚拟机的主流垃圾回收器采取的可达性分析算法。这个算法的实质在于将一系列GC Roots作为初始的存活对象集合（live Set），然后从该集合出发，
探索所有能够被该集合引用的对象，并加入到该集合中，这个过程就是标记过程。最终，未被探索到的对象便是死亡，是可回收的。

那么什么是GC Roots，其实就是由堆外指向堆内的，一般GC Roots包括一下几种：
* 1：Java方法栈中的局部变量。
* 2：已加载类的静态变量。
* 3：JNI中引用对象。
* 4：已启动但为停止的Java线程

虽然可达性分析，可以解决循环引用问题，但自身也存在一些问题，比如说，在多线程下，其他线程可能会更新已经访问过的对象中的引用，
从而造成误报（将引用设置为null）或者漏报（将引用设置为未被访问过的对象）。
![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-gc2.png?raw=true)

### 垃圾收集算法
其实垃圾回收目前就三种方式，清除、压缩与复制，下面我们分别来看下这几种算法的过程。
* 1：标记-清除
    根据名字，就知道，这个算法是分为两步的，先标记需要回收的对象，然后再同一回收，具体过程看下图所示：
![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-gc3.png?raw=true) 
很明显，这个算法经过多次收集后，回出现很多内存碎片，之后可能对于大对象无法存放。

* 2：复制算法
复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，
就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-gc4.png?raw=true) 

* 3：标记-整理算法
标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，
并更新对应的指针。标记-整理算法是在**标记-清除算法的基础上，又进行了对象的移动**，因此成本更高，但是却解决了内存碎片的问题。
![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-gc5.png?raw=true) 

* 4：分代收集算法(这个还要细高一下)[参考](https://www.cnblogs.com/aspirant/p/8662690.html)
分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。
一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，
而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

#### 几种算法的比较

算法 | 优点 | 缺点 | 
:-: | :-: | :-:   | 
标记-清除 | 简单 | 1. 标记和清除两个过程的效率都不高；2. 标记清除之后会产生大量不连续的内存碎片 |
复制 | 实现简单，运行高效 | 1. 减少了内存使用空间；2. 在对象存活率较高时需要进行较多的复制操作（不适合老年代）|
标记-整理 | 根据老年代的特点提出的一种算法，适合老年代 |只适合于某些特定情况| 
分代收集 | 使用多种收集算法，根据各自的特点选用不同的收集算法 | 具体实现过程比较复制|  

### 垃圾收集器
收集器可以从两个方面进行分类：
* 1：单线程或者多线程。
* 2：收集对象类型。

下面看下收集器图，其中上面区域表示收集的是年轻代，下面区域收集的是老年代，当然G1收集器是都可以的。
线条连接的两个收集器，说明可以组合一起使用。
![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-gc6.png?raw=true) 

#### Serial 收集器(复制算法)
新生代单线程收集器，标记和清理都是单线程，优点是简单高效。它只会是使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束
是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定。
![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-gc7.png?raw=true) 

#### Serial Old 收集器(标记-整理算法)
Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用 “标记-整理” 算法。Serial/Serial old 收集器的运行过程如图
![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-gc8.png?raw=true) 

#### ParNew收集器(停止-复制算法)　
新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。
由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 Serial 收集器。但是，当 CPU 的数量增加时，
它对于 GC 时系统资源的有效利用还是很有好处的，
它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多（使用超线程时）的环境下，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数。
ParNew/Serial old 收集器的运行过程如下图所示：

![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-gc9.png?raw=true) 

#### Parallel Scavenge收集器(停止-复制算法)
并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。是server级别默认采用的GC方式，
可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数。

#### Parallel Old收集器(停止-复制算法)
Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先。

#### CMS(Concurrent Mark Sweep)收集器（标记-清理算法）
整个过程分为4个步骤：1. 初始标记（CMS initial mark） 2. 并发标记（CMS concurrent mark） 3. 重新标记（CMS remark） 4. 并发清除（CMS concurrent sweep）

有以下几个特点：
   * 1： 其中，初试标记、重新标记这两个步骤仍然需要 “Stop The World”。
   * 2： 初始标记只是标记一下 GC Roots 能直接关联到的对象，速度很快。
   * 3： 并发标记阶段就是进行 GC Roots Tracing 的过程。
   * 4：重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初试标记阶段稍长一些，但远比并发标记的时间短。

#### G1收集器
G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。
老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。	

#### 几种收集器比较

收集器 | 特征 | 使用场景 | 
:-: | :-: | :-:   | 
Serial 收集器 | 复制算法；单线程；新生代；简单而高效；需要进行 stop the world。| 它是虚拟机运行在 Client 模式下的默认新生代收集器 |
ParNew 收集器 | ParNew 收集器 |它是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作。|
Parallel Scavenge 收集器| 复制算法；并行多线程；新生代；吞吐量优先原则；有自适应调节策略 |适合后台运算而不需要太多交互的任务| 
Serial Old 收集器 | 标记-整理算法；老年代；单线程；| 这个收集器的主要意义在于给 Client 模式下的虚拟机使用|  
Parallel Old 收集器 | 标记-整理；老年代；多线程；与 parallel scavenge 收集器结合实现吞吐量优先| 与 Parallel Scavenge 结合使用，适用那些注重吞吐量以及对 CPU 资源敏感的场合|  
CMS 收集器 | 标记-清除；老年代；并发收集、低停顿；有三个缺点| 标记-清除；老年代；并发收集、低停顿；有三个缺点|  
G1 收集器 | 分代收集；空间整合；可预测的停顿| 面向服务器应用垃圾收集器|  

### 分配策略

#### 安全点 (Safe Point)

#### STW

#### 空间分配担保


