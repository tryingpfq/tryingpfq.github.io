---
layout:     post
title:      垃圾回收
subtitle:   垃圾回收器和算法，以及内存分配策略
date:       2019-03-13
author:     tryingpfq
header-img: img/post-bg-gc1.jpg
catalog: true
tags:
    - JVM
---

> 对于来及回收，对于Java程序员来说应该是不陌生的。想要长远的发展，必须对这块机制有所了解，
这样才能写出更高效的代码。如果遇到性能的瓶颈，那么肯定要从这方面去分析，做一些调优。

### 前言
垃圾回收，在Java虚拟机中，垃圾指的是死亡对象所占用的空间，顾明思议就是对内存中已死的对象进行回收，那么如何找出已死的对象，如何进行回收，已近新的对象内存如何分配，
就是垃圾回收要考虑的地方。

### 如何判断对象已死
所谓的对象已死，就是在内存中游离的对象，没有再被用到，但有占用空间，目前主要有两种方法去判断。

#### 引用计数法
这个做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数，每当有一个地方引用它时，计数器+1，当失效后会减1。
一旦该对象的引用计数器为0，则说明该对象已死亡，便可以被回收。

**这种方法会带来一个问题**：除了需要格外的空间来存储引用计数器，以及繁琐的更新操作，还有一个重大漏洞，那就是无法处理循环引用
问题。下面这两个对象是不会被标记会死亡的：
![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-gc1.png?raw=true)

#### 可达性分析
目前Java虚拟机的主流垃圾回收器采取的可达性分析算法。这个算法的实质在于将一系列GC Roots作为初始的存活对象集合（live Set），然后从该集合出发，
探索所有能够被该集合引用的对象，并加入到该集合中，这个过程就是标记过程。最终，未被探索到的对象便是死亡，是可回收的。

那么什么是GC Roots，其实就是由堆外指向堆内的，一般GC Roots包括一下几种：
* 1：Java方法栈中的局部变量。
* 2：已加载类的静态变量。
* 3：JNI中引用对象。
* 4：已启动但为停止的Java线程

虽然可达性分析，可以解决循环引用问题，但自身也存在一些问题，比如说，在多线程下，其他线程可能会更新已经访问过的对象中的引用，
从而造成误报（将引用设置为null）或者漏报（将引用设置为未被访问过的对象）。
![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-gc2.png?raw=true)

### 垃圾收集算法
其实垃圾回收目前就三种方式，清除、压缩与复制，下面我们分别来看下这几种算法的过程。
* 1：标记-清除
    根据名字，就知道，这个算法是分为两步的，先标记需要回收的对象，然后再同一回收，具体过程看下图所示：
![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-gc3.png?raw=true) 
很明显，这个算法经过多次收集后，回出现很多内存碎片，之后可能对于大对象无法存放。

* 2：复制算法
复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，
就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-gc4.png?raw=true) 

* 3：标记-整理算法
标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，
并更新对应的指针。标记-整理算法是在**标记-清除算法的基础上，又进行了对象的移动**，因此成本更高，但是却解决了内存碎片的问题。
![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-gc5.png?raw=true) 

* 4：分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。
一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，
而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

#### 几种算法的比较
算法 | 优点 | 缺点 | 
:-: | :-: | :-:   | 
标记-清除 | 简单 | 1. 标记和清除两个过程的效率都不高；2. 标记清除之后会产生大量不连续的内存碎片 |
复制 | 实现简单，运行高效 | 1. 减少了内存使用空间；2. 在对象存活率较高时需要进行较多的复制操作（不适合老年代）|
标记-整理 | 根据老年代的特点提出的一种算法，适合老年代 |只适合于某些特定情况| 
分代收集 | 使用多种收集算法，根据各自的特点选用不同的收集算法 | 具体实现过程比较复制|  

### 垃圾收集器

### 分配策略
