### ZK源码分析



### 基础篇

#### zk数据模型：如何使用Watch机制实现分布式通知

##### 数据模型



##### 节点类型

1：持久节点

2：临时节点

3：有序节点

 ZooKeeper 中的每个节点都维护有这些内容：一个二进制数组（byte data[]），用来存储节点的数据、ACL 访问控制信息、子节点数据（因为临时节点不允许有子节点，所以其子节点字段为 null），除此之外每个数据节点还有一个记录自身状态信息的字段 stat。



##### 使用zk实现锁

悲观锁

乐观锁

乐观锁认为，进程对临界区资源的竞争不会总是出现，所以相对悲观锁而言。加锁方式没有那么激烈，不会全程的锁定资源，而是在数据进行提交更新的时候，对数据的冲突与否进行检测，如果发现冲突了，则拒绝操作。





问题：为什么zk不采用相对路劲来查找节点?

这是因为 ZooKeeper 大多是应用场景是定位数据模型上的节点，并在相关节点上进行操作。像这种查找与给定值相等的记录问题最适合用散列来解决。因此 ZooKeeper 在底层实现的时候，使用了一个 hashtable，即 hashtableConcurrentHashMap<String, DataNode> nodes ，用节点的完整路径来作为 key 存储节点数据。



#### 发布订阅模式：如何使用Watch机制实现分布式通知



##### watch机制是如何实现的



####  ACL权限控制：如何避免未经授权的访问？



#### 序列化机制：JUTE



### 进阶篇



#### 单机模式：服务器如何从初始化到对外提供服务



#### 集群模式：服务器如何从初始化到对外提供服务

