---
layout:     post
title:      RMI
subtitle:   RMI的实现
date:       2019-06-01
author:     tryingpfq
header-img: img/post-load-class2.jpg
catalog: true
tags:
    - JVM
---

> RMI(Remote method invocation),可以认为是RPC的一个Java版本，
虽然现在不会用到这个，但是它基于早起的出现，基于RPC这种设计思想在现在很多地方还是可以看到的。

### 前言
RMI使用的是JRMP通信协议，它的序列化机制还是基于Java本身的servilized，所以在使用上是很受限制的。

### RMI的实现过程
* 1:创建远程接口，并且继承Remote接口
* 2：实现远程接口，并且继承UnicastRemoteObject
* 3：创建服务程序，createRegistry方法注册远程对象
* 4：创建客户端程序

**下面看一下具体实现的demo**

	//接口

    public interface RegistryDoImplDemo extends Remote {

    String doDemo(String str) throws RemoteException;
}

	//实现类
	public class ImplRegistryDemo extends UnicastRemoteObject implements RegistryDoImplDemo {

    public ImplRegistryDemo() throws RemoteException{
        super();
    }

    @Override
    public String doDemo(String string) throws RemoteException {
        return "hell Registry " + string;
    }
}

	//服务端程序
	public class RegistryService {
   		public static void main(String[] args) {

        try {
            Registry registry = LocateRegistry.createRegistry(8888);

            //创建一个远程对象
            RegistryDoImplDemo registryDoImplDemo = new ImplRegistryDemo();

            registry.rebind("helloRegistry",registryDoImplDemo);

            System.out.println("RMI 成功启动");
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }
}

	//客户端程序
	public class RegistryClient {

    public static void main(String[] args) {
        try {
            Registry registry = LocateRegistry.getRegistry(8888);

            RegistryDoImplDemo helloDemo = (RegistryDoImplDemo) registry.lookup("helloRegistry");
            String response = helloDemo.doDemo("pfq");

            System.out.println("response " + response);
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (NotBoundException e) {
            e.printStackTrace();
        }
    }
}

当启动后，就可以通过registry.lookup方法，调用远程方法。这里要注意的是，服务端创建的registry和客户端获得的registry要是同一个，并且端口要一样。

