---
layout:     post
title:      zookeeper
subtitle:   zookeeper源码分析
date:       2020-03-30
author:     tryingpfq
header-img: img/post-bg-fenbushi.jpg
catalog: true
tags:
    - zookeeper - 分布式
---


> 就最近不是很忙，在看分布式有关的东西，然后就有用到zookeeper，觉得好奇，就打算把源码看看。

### 通信

 * zookeeper与客户端的通信，默认使用的是`org.apache.zookeeper.server.NIOServerCnxnFactory`,当然也可以通过配置
 使用自己想要的，比如// -Dzookeeper.serverCnxnFactory=org.apache.zookeeper.server.NettyServerCnxnFactory，用的就是Netty

 大概说下NIOServerCnxnFactory，看名字就能理解到，这个是基于NIO的，在初始化的时候，会定义一个AcceptThread线程，里面维护了selectorIterator集合
 ，这个数量是根据配置定义的，我默认启动是2，这两个线程就是用来对监听客户端的连接的。具体的实现，看下里面代码，还是比较容易理解的。

~~~java
 //连接成功后，对后面的读写
private void select() {
            try {
                selector.select();

                Set<SelectionKey> selected = selector.selectedKeys();
                ArrayList<SelectionKey> selectedList =
                    new ArrayList<SelectionKey>(selected);
                Collections.shuffle(selectedList);
                Iterator<SelectionKey> selectedKeys = selectedList.iterator();
                while(!stopped && selectedKeys.hasNext()) {
                    SelectionKey key = selectedKeys.next();
                    selected.remove(key);

                    if (!key.isValid()) {
                        cleanupSelectionKey(key);
                        continue;
                    }
                    if (key.isReadable() || key.isWritable()) {
                        //看下这个方法就可以了
                        handleIO(key);
                    } else {
                        LOG.warn("Unexpected ops in select " + key.readyOps());
                    }
                }
            } catch (IOException e) {
                LOG.warn("Ignoring IOException while selecting", e);
            }
        }

 	private void handleIO(SelectionKey key) {
        	
            IOWorkRequest workRequest = new IOWorkRequest(this, key);
            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();

            // Stop selecting this key while processing on its
            // connection
            cnxn.disableSelectable();
            key.interestOps(0);
            touchCnxn(cnxn);
        	//这里就是封装一下放到线程池中去了
        	//看到这有想到和nettyNio 的区别吗?这里线程应该是随机的，而不像netty那样，一个客户端的读写
        	//线程是固定的
            workerPool.schedule(workRequest);
        }
~~~





### 客户端请求

客户端的请求，首先是封装成一个`SyncRequestProcessor`,这是一个zk线程。run方法中会调用nextProcessor.processRequest(si)这里应该是执行的核心了，很长，但逻辑还是比较清晰。其实我们大部分操作都是基于节点操作的，操作完之后，会发结果封装成一个Response,返回给客户端，应该每个Response都会继承

`org.apache.jute.Record`,最后是通过org.apache.zookeeper.server.ServerCnxn#sendResponse(r) 把结果返回给客户端。



### 数据存储

每个ZooKeeperServer(leader follower observer) 都会有一个ZKDatabase，看到这个名字就是zk数据库了，详细的数据保存在DataTree类中。