



《Effective Java》



### 创建和销毁对象

这里的主题是创建和销毁对象：何时以及如何创建对象，何时以及如何避免创建对象，如何确保他们能够在合适的时间销毁，以及如何管理对象销毁之前必须进行的各种清理操作。

`1：用静态工厂代替构造器。`

平时，我们习惯通过new然后去创建对象，那是否可以考虑提供一个共有的静态工厂方法，只是用来返回类的实类静态方法。



2：`遇到多个构造器参数时要考虑使用构造器`

静态工厂和构造器有个共同的局限性：他们都不能扩展到大量的可选参数。经常程序员可能习惯用重叠构造器模式，可是当遇到很多参数的时候，可能就不太方便了，也不方便阅读。

然后可能会想到一个方法。就是下面这样。

```java
vo.setA(a);
vo.setB(b);
vo.setC(c);
.....
你能知道这样会有什么问题吗，不仅仅是可能要写很多行的set方法。
这样vo可能处于不一致的桩体，因为如果是在构造函数中是并发安全的(这个具体，待研究)
   
```

平时有没有遇到过通过建造者模式来处理这种多参数的构造，而且还可以对一些必须的参数进行校验，如果检查失败，就可以抛出IllegalArgumentException。这样的代码是不是很容易编写，而且易于阅读。

与构造器相比，builder的稍微优势在于，它可以有多个可变参数，因为builder是利用单独的方法来设置每一个参数。

而且Builder模式比较灵活，可以自动填充需要某些域。但也存在一些不足，为了创建对象，必须先创建它的构造器。简而言之，如果类的构造器或者静态工厂中具有多个参数，通过Builder模式是一个不错的选择。



3：`用私有构造器或者枚举类型强化Singleton属性`

这里不多说，但要注意几个点

可以借助AccessibleObject.setAccessible()方法，通过反射机制调用私有构造器。

若实现了Serializable接口的单列，为了维护并保证Singleton，必须申明所有实例域都是瞬间的，并提供一个readResolve方法。否则每次反序列化都会破坏单例。

但如果是通过枚举就不同了，无偿的提供了反序列化机制。单元素的枚举类型经常被成为实现单例的最佳实战。



4：`通过私有构造器强化不可实例化的能力`

