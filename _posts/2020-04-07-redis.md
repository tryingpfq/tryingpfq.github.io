---
layout:     post
title:      Redis
subtitle:  	Redis
date:       2020-04-07
author:     tryingpfq
header-img: img/bg-redis.jpg
catalog: true
tags:

    - redis
---



### 安装

[下载](http://download.redis.io/releases/)

tar 解压 

make （make前需要安装Gcc,用yum安装最简单了 yum -y install gcc gcc-c++ kernel-devel //安装gcc、c++编译器以及内核文件）

make test（test 之前需要安装[tcl](https://blog.csdn.net/yanci_/article/details/79959388)）

可以格外创建一个目录用来安装 make redis

make install PREFIX=/usr/data/redis

安装好后，到redis-3.2.8 下拷贝一个文件但redis目录下：cp redis.conf ../redis/redis.conf

安装完后，源码就可以删了



* 启动  要指定conf:   ./redis-server ../redis.conf
* 要在后台运行的话，需要改配置 redis.conf，修改daemonize yes  
* 关闭redis, ./redis-cli shutdown
* 查看 ps -ef|grep redis
* 进入客户端本地  ./redis-cli    ,访问远程  ./redis-cli -h 192.168.146.11 -p 6379
* 关闭 在客户端中shutdown即可，外面就 ./redis-cli shutdown, **shutdown nosave**命令强行终止，不要用kill



### 基本概念

**多数据库支持**

默认支持16个数据库，可以理解为一个命名空间

跟其他关系型数据库不一样的地方有

1：redis不支持自定义数据库名词

2：每个数据库不能单独设置授权

3：每个数据库之间并不是完全隔离的，可以通过flushall命令清空redis实例面的所有数据库中的数据

可通过 select dbid 去选择不同的数据空命名空间 id范围为 0-15



**基本操作**

1：获取一个符合匹配规则的键名列表

​		keys parttern [? * /]

2：判断一个键是否存在

​		exits key

3：type key 获得这个key的数据结构类型



**各种数据结构的使用**

1：字符类型

​	一个字符类型的key默认存储的最大容量是512M

​	赋值和取值 SET key value     GET key

​	递增数字（原子递增）：incr key   incryby key increment 自定义递增大小

​	原子递减 decr key

​	字符串追加 append key -value

​	获得多个key的value mget key1 key2 key3  同时设置多个key 的value  mset key2 value2 key1 value1

2： 列表类型

​	list:可以存储一个有序的字符串列表

​	lpush/rpush key val......  左右添加数据  lpop/rpop key 取出并移除数据

​	llen key 获得列表长度

​	lrang/rrange key start stop(-1表示最大)  获取区间中的数据

​	lrem key count value 	删除列表值为value 数量为count

​	lset key index value  设置对应索引的值

​	应用场景：**可以用来做分布式队列**

3： 散列类型

​	hash:  key value 形式 不支持数据类型的嵌套

​	比较适合存储对象

​	比如：person:{age,sex,name}

​	hset key filed value , hset person person.age 20  hset person person.name try

​	hget key filed, hget person person.age

​	同样有hset key filed value filed2 value ....,hmget

​	hgetall key,获取hash的所有信息，包括key value

​	hexits key filed  返回 0 1，判断字段是否存在

​	hdel key filed1 filed2.....

4：集合类型

​		set  和 list不同的是，不能存在重复的数据，且有序

​		sadd key member [member....]  增加数据，如果value存在，则会直接覆盖，并返回成功加入后的元素数量

​		srem key member

​		smembers key 获取所有数据 

​		sdiff key1 key2.... 差集运算

​		sunion key1 key2... 并集运算

​		

5：有序集合

​	zadd key score member key2 score memeber (会根据score 排序)

​	zrange key start stop [withscores]  获取元素 



### redis应用

**redis事物**

开启事物：multi  提交事务：exec



**过期时间**

expire key seconds  设置key的过期时间

ttl key 获取剩余超时时间



**发布订阅**

这个应该很少用，用专门的消息中间件实现更好。



**redis实现分布式锁**

话不多说，直接上简单的代码实现,注意下，连接redis时，需要修改下redis.conf,将bind:ip  注释掉，还有就是protect-demo 修改为no

```java
public class RedisManager {
    private static JedisPool jedisPool;

    static{
        JedisPoolConfig poolConfig = new JedisPoolConfig();
        poolConfig.setMaxTotal(20);
        poolConfig.setMaxIdle(10);
        jedisPool = new JedisPool(poolConfig, JedisProperties.HOST, 6379);
    }

    public static Jedis getJedis() throws Exception {
        if (jedisPool != null) {
            return jedisPool.getResource();
        }
        throw new Exception("jedisPool is null");
    }
}

public class RedisLock {
    private String lockValue;

    public String getLock(String key, int tryTimeOut, int expire) {
        try {
            Jedis jedis = RedisManager.getJedis();
            String uuid = UUID.randomUUID().toString();
            long endTime = System.currentTimeMillis() + tryTimeOut;
            while (System.currentTimeMillis() < endTime) {
                if (jedis.setnx(key, uuid) == 1) {//这个地方不是阻塞的 所以要只是延迟请求时间
                    //设置超时时间
                    jedis.expire(key, expire);
                    this.lockValue = uuid;
                    return lockValue;
                }
                //防止在设置超时时间前，连接挂了
                if (jedis.ttl(key) < 0) {
                    jedis.expire(key, expire);
                }
                Thread.sleep(1000L);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public boolean releaseLock(String key, String lockValue) {
        try {
            Jedis jedis = RedisManager.getJedis();
            while (true) {
                jedis.watch(key);
                if (lockValue.equals(jedis.get(key))) {
                    Transaction transaction = jedis.multi();
                    transaction.del(key);
                    List<Object> list = transaction.exec();
                    if (list == null) {
                        continue;
                    }
                    return true;
                }
                jedis.unwatch();
                break;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }


    public static void main(String[] args) throws InterruptedException {
        RedisLock redisLock = new RedisLock();
        String key = "lock:one";
        String lock = redisLock.getLock(key, 2000, 10);
        if (lock != null) {
            System.err.println("lock success :" + lock);
        }
        String lock2 = redisLock.getLock(key, 1000, 10);
        if (lock2 == null) {
            System.err.println("second get fail");
        }
        Thread.sleep(3);
       // redisLock.releaseLock(key, lock);
    }
}
```



**lua脚本在redis中的应用**

lua脚本在redis中的执行是一个原子过程，也就是说，在脚本中调用的所有redis命令操作会在一个事物中执行。

redis的脚本执行是原子的，即脚本执行期间Redis不会执行其他命令。所有的命令必须等待脚本执行完以后才能执行。为了防止某个脚本执行时间过程导致Redis无法提供服务。Redis提供了lua-time-limit参数限制脚本的最长运行时间。默认是5秒钟。



* lua在linux中的安装

  到官网下载lua的tar.gz的源码包

  tar -zxvf lua-5.3.0.tar.gz

  进入解压的目录：

  cd lua-5.2.0

  make linux (linux环境下编译)

  make install

  如果报错，说找不到readline/readline.h, 可以通过yum命令安装：yum -y install readline-devel ncurses-devel

  安装完以后再make linux / make install

  最后，直接输入 lua命令即可进入lua的控制台

  

* 看个案例，比如我们对某个IP访问做次数限制，下面是这段lua脚本。

```lua
--注意KEY 和参数都要大写 这里第一个参数是过期时间，第二个是范围限制次数
local num=redis.call('incr',KEYS[1])
if tonumber(num)==1 then
    redis.call('expire',KEYS[1],ARGV[1])
    return 1
elseif tonumber(num)>tonumber(ARGV[2]) then
    return 0
else
    return 1
end
```

当然可以直接在redis客户端下直接运行，把脚本保存在本地目录，执行命令为，下面有个坑，参数之间要空格。

`./redis-cli --eval "ip_limit.lua" ip:limit:192.168.146.140 , 6000 10`



生产的时候肯定是通过读取脚本，然后加载脚本得到一个摘要，这个摘要会对应这个脚本缓存在redis内存中，后续访问只需要传递摘要即可，话不多说，上代码。

```java
public class LuaUse {
    //当然我们一般是从文件去加载
    public static final String SCRIPT_STR = "local num=redis.call('incr',KEYS[1])\n" +
            "if tonumber(num)==1 then\n" +
            "    redis.call('expire',KEYS[1],ARGV[1])\n" +
            "    return 1\n" +
            "elseif tonumber(num)>tonumber(ARGV[2]) then\n" +
            "    return 0\n" +
            "else\n" +
            "    return 1\n" +
            "end";

    public static void main(String[] args) throws Exception {
        Jedis jedis = RedisManager.getJedis();
        List<String> keys = new ArrayList<>();
        keys.add("ip:limit:192.168.146.128");
        List<String> argvs = new ArrayList<>();
        argvs.add("6000");
        argvs.add("10");
        Object o = jedis.evalsha(jedis.scriptLoad(SCRIPT_STR), keys, argvs);
        System.err.println(o);
    }
}
```



