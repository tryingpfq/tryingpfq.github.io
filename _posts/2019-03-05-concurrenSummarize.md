---
layout:     post
title:      并发编程
subtitle:   并发编程概述
date:       2019-03-05
author:     tryingpfq
header-img: img/post-bg-concuCode.jpg
catalog: true
tags:
     - 并发编程
---

> 并发编程可以总结三个核心问题：分工、同步、互斥

### 分工
  所谓分工，其实就是类似管理者和被管理者，管理者将任务进行分工给下手去完成。
  Java SDK并发编程包里的Executor、Fork/Join、Future其实本质上就是一种
  分工方法。其实还有生产者-消费者模型也是一种分工方法。
  
  
### 同步
  通常一项任务，是需要协同合作完成的，在并发编程的领域里，同步主要指的是线程之间
  的协作，即一个线程完成了一个任务，如何通知执行后续任务的线程开工。
  Java SDK里提供的CountDownLatch就是典型用来解决线程协同问题的
  
  线程协同问题，基本上就是当某个条件不满足时，线程需要等待，当某个条件满足时，
  线程需要被唤醒执行。例如生产者和消费者也类似，当队列满了的时候，生成者线程
  需要等待，当不满时，生产者线程需要被唤醒。反之，消费者线程需要等待。
  
  java并发编程中，解决协同问题的核心技术是管程。
  
  
### 互斥
  分工、同步主要强调性能，而互斥注重的是安全，也就是所谓的“线程安全”。
  当多个线程同时访问同一个共享变量的时候，就会存在线程安全问题。而导致这种
  安全问题的源头是可见性、有序性和原子性问题。解决线程安全问题的核心就是互斥，
  即同一时刻，只允许一个线程访问共享变量。
  
  实现互斥的核心技术就是锁，如synchronize，SDK中的各种Lock,原子类基于无锁
  技术实现。其实还有，比如final、Thread Local,其原理是只允许读。
  
  当然，使用锁也存在一些弊端，比如影响性能，而且可能导致死锁问题。比如ReenteentLock的使用，
  如果在被锁的区域最后，忘记释放锁，就会导致死锁问题。
  
  并发知识全景图
  ![极客时间-王老师](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-concuCode.png?raw=true)
  
  参考[极客时间-Java并发实战](https://time.geekbang.org/column/159)



