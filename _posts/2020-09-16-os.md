---
layout:     post
title:      操作系统
subtitle:   重学操作系统
date:       2020-09-16
author:     tryingpfq
header-img: img/try-os.jpg
catalog: true
tags:

    - READE-NODE
---



### 计算机组成原理



#### 程序的执行：相比32位，64位的优势是什么

首先了解一下冯诺依曼计算机结构：输出设备、输出设备、内存、中央处理器、总线。

![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/try-os1.jpg?raw=true)



* 内存

  在冯诺依曼模型中，程序和数据被存储在一个被称作内存的线性排列存储区域。存储的数据单位是一个二进制位，英文是 bit。最小的存储单位叫作字节，也就是 8 位，英文是 byte，每一个字节都对应一个内存地址。内存地址由 0 开始编号，比如第 1 个地址是 0，第二个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。

  我们通常说的内存都是随机存取器，也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。

* CPU

  冯诺依曼模型中 CPU 负责控制和计算。为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。

  * 如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；

  * 如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU。

  这里的 32 和 64，称作 CPU 的位宽。

  为什么 CPU 要这样设计呢？ 因为一个 byte 最大的表示范围就是 0~255。比如要计算 20000*50，就超出了byte 最大的表示范围了。因此，CPU 需要支持多个 byte 一起计算。当然，CPU 位数越大，可以计算的数值就越大。但是在现实生活中不一定需要计算这么大的数值。比如说 32 位 CPU 能计算的最大整数是 4294967295，这已经非常大了。

* 控制单元和逻辑运算单元

  CPU 中有一个控制单元专门负责控制 CPU 工作；还有逻辑运算单元专门负责计算。

* 寄存器

  CPU 要进行计算，比如最简单的加和两个数字时，因为 CPU 离内存太远，所以需要一种离自己近的存储来存储将要被计算的数字。这种存储就是寄存器。寄存器就在 CPU 里，控制单元和逻辑运算单元非常近，因此速度很快。

  寄存器中有一部分是可供用户编程用的，比如用来存加和指令的两个参数，是通用寄存器。

  还有一部分寄存器有特殊的用途，叫作特殊寄存器。比如程序指针，就是一个特殊寄存器。它存储了 CPU 要执行的下一条指令所在的内存地址。注意，程序指针不是存储了下一条要执行的指令，此时指令还在内存中，程序指针只是存储了下一条指令的地址。

  下一条要执行的指令，会从内存读入到另一个特殊的寄存器中，这个寄存器叫作指令寄存器。指令被执行完成之前，指令都存储在这里。

* 总线

  CPU 和内存以及其他设备之间，也需要通信，因此我们用一种特殊的设备进行控制，就是总线。总线分成 3 种：

  一种是地址总线，专门用来指定 CPU 将要操作的内存地址。

  还有一种是数据总线，用来读写内存中的数据。

  当 CPU 需要读写内存的时候，先要通过地址总线来指定内存地址，再通过数据总线来传输数据。

  最后一种总线叫作控制总线，用来发送和接收关键信号，比如后面我们会学到的中断信号，还有设备复位、就绪等信号，都是通过控制总线传输。同样的，CPU 需要对这些信号进行响应，这也需要控制总线。

* 输出、输出设备

  输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。如果输入设备、输出设备想要和 CPU 进行交互，比如说用户按键需要 CPU 响应，这时候就需要用到控制总线。



**程序在计算机中的执行过程**

* 首先，CPU 读取 PC 指针指向的指令，将它导入指令寄存器。具体来说，完成读取指令这件事情有 3 个步骤：

  步骤 1：CPU 的控制单元操作地址总线指定需要访问的内存地址（简单理解，就是把 PC 指针中的值拷贝到地址总线中）。

  步骤 2：CPU 通知内存设备准备数据（内存设备准备好了，就通过数据总线将数据传送给 CPU）。

  步骤 3：CPU 收到内存传来的数据后，将这个数据存入指令寄存器。

  完成以上 3 步，CPU 成功读取了 PC 指针指向指令，存入了指令寄存器。

* CPU分析指令寄存器中的指令，确定指令的类型和参数。

* 如果是计算类型的指令，那么就交给逻辑运算单元计算；如果是存储类型的指令，那么由控制单元执行。

* PC指针自增，并准备获取下一条指令。

  比如在 32 位的机器上，指令是 32 位 4 个字节，需要 4 个内存地址存储，因此 PC 指针会自增 4。



回到上面的问题：

* 如果说的是 64 位宽 CPU，那么有 2 个优势：

  优势 1：64 位 CPU 可以执行更大数字的运算，这个优势在普通应用上不明显，但是对于数值计算较多的应用就非常明显。

  优势 2：64 位 CPU 可以寻址更大的内存空间

* 如果 32 位/64 位说的是程序，那么说的是指令是 64 位还是 32 位的。32 位指令在 64 位机器上执行，困难不大，可以兼容。 如果是 64 位指令，在 32 位机器上执行就困难了。因为 32 位指令在 64 位机器执行的时候，需要的是一套兼容机制；但是 64 位指令在 32 位机器上执行，32 位的寄存器都存不下指令的参数。

* 操作系统也是一种程序，如果是 64 位操作系统，也就是操作系统中程序的指令都是 64 位指令，因此不能安装在 32 位机器上。



####  存储器分级：L1 Cache 比内存和 SSD 快多少倍？

首先，要了解缓存，寄存器，L1,L2,L3，内存，SSD

* 寄存器的数量通常在几十到几百之间，每个寄存器可以用来存储一定字节（byte）的数据。比如：

  32 位 CPU 中大多数寄存器可以存储 4 个字节；

  64 位 CPU 中大多数寄存器可以存储 8 个字节。

  寄存机的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写。比如一条要在 4 个周期内完成的指令，除了读写寄存器，还需要解码指令、控制指令执行和计算。如果寄存器的速度太慢，那 4 个周期就可能无法完成这条指令了。

* L1- 缓存在 CPU 中，相比寄存器，虽然它的位置距离 CPU 核心更远，但造价更低。通常 L1-Cache 大小在几十 Kb 到几百 Kb 不等，读写速度在 2～4 个 CPU 时钟周期。

* L2- 缓存也在 CPU 中，位置比 L1- 缓存距离 CPU 核心更远。它的大小比 L1-Cache 更大，具体大小要看 CPU 型号，有 2M 的，也有更小或者更大的，速度在 10～20 个 CPU 周期。

* L3- 缓存同样在 CPU 中，位置比 L2- 缓存距离 CPU 核心更远。大小通常比 L2-Cache 更大，读写速度在 20-60 个 CPU 周期。L3 缓存大小也是看型号的，比如 i9 CPU 有 512K L1 Cache；有 2MB L2 Cache； 有16MB L3 Cache。

* 内存的主要材料是半导体硅，是插在主板上工作的。因为它的位置距离 CPU 有一段距离，所以需要用总线和 CPU 连接。因为内存有了独立的空间，所以体积更大，造价也比上面提到的存储器低得多。现在有的个人电脑上的内存是 16G，但有些服务器的内存可以到几个 T。内存速度大概在 200～300 个 CPU 周期之间。

* SSD 也叫固态硬盘，结构和内存类似，但是它的优点在于断电后数据还在。内存、寄存器、缓存断电后数据就消失了。内存的读写速度比 SSD 大概快 10~1000 倍。以前还有一种物理读写的磁盘，我们也叫作硬盘，它的速度比内存慢 100W 倍左右。因为它的速度太慢，现在已经逐渐被 SSD 替代。

回到上面问题

因为内存比 SSD 快 10~1000 倍，L1 Cache 比内存快 100 倍左右。因此 L1 Cache 比 SSD 快了 1000~10000 倍。

这个问题告诉我们，不同的存储器之间性能差距很大，我们写程序的时候应该尽可能使用 CPU 缓存。



**问题**

假设有一个二维数组，总共有 1M 个条目，如果我们要遍历这个二维数组，应该逐行遍历还是逐列遍历？