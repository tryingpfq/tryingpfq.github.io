---
layout:     post
title:      操作系统
subtitle:   重学操作系统
date:       2020-09-16
author:     tryingpfq
header-img: img/try-os.jpg
catalog: true
tags:

    - 操作系统
---



### 计算机组成原理



#### 程序的执行：相比32位，64位的优势是什么

首先了解一下冯诺依曼计算机结构：输出设备、输出设备、内存、中央处理器、总线。

![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/try-os1.jpg?raw=true)



* 内存

  在冯诺依曼模型中，程序和数据被存储在一个被称作内存的线性排列存储区域。存储的数据单位是一个二进制位，英文是 bit。最小的存储单位叫作字节，也就是 8 位，英文是 byte，每一个字节都对应一个内存地址。内存地址由 0 开始编号，比如第 1 个地址是 0，第二个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。

  我们通常说的内存都是随机存取器，也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。

* CPU

  冯诺依曼模型中 CPU 负责控制和计算。为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。

  * 如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；

  * 如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU。

  这里的 32 和 64，称作 CPU 的位宽。

  为什么 CPU 要这样设计呢？ 因为一个 byte 最大的表示范围就是 0~255。比如要计算 20000*50，就超出了byte 最大的表示范围了。因此，CPU 需要支持多个 byte 一起计算。当然，CPU 位数越大，可以计算的数值就越大。但是在现实生活中不一定需要计算这么大的数值。比如说 32 位 CPU 能计算的最大整数是 4294967295，这已经非常大了。

* 控制单元和逻辑运算单元

  CPU 中有一个控制单元专门负责控制 CPU 工作；还有逻辑运算单元专门负责计算。

* 寄存器

  CPU 要进行计算，比如最简单的加和两个数字时，因为 CPU 离内存太远，所以需要一种离自己近的存储来存储将要被计算的数字。这种存储就是寄存器。寄存器就在 CPU 里，控制单元和逻辑运算单元非常近，因此速度很快。

  寄存器中有一部分是可供用户编程用的，比如用来存加和指令的两个参数，是通用寄存器。

  还有一部分寄存器有特殊的用途，叫作特殊寄存器。比如程序指针，就是一个特殊寄存器。它存储了 CPU 要执行的下一条指令所在的内存地址。注意，程序指针不是存储了下一条要执行的指令，此时指令还在内存中，程序指针只是存储了下一条指令的地址。

  下一条要执行的指令，会从内存读入到另一个特殊的寄存器中，这个寄存器叫作指令寄存器。指令被执行完成之前，指令都存储在这里。

* 总线

  CPU 和内存以及其他设备之间，也需要通信，因此我们用一种特殊的设备进行控制，就是总线。总线分成 3 种：

  一种是地址总线，专门用来指定 CPU 将要操作的内存地址。

  还有一种是数据总线，用来读写内存中的数据。

  当 CPU 需要读写内存的时候，先要通过地址总线来指定内存地址，再通过数据总线来传输数据。

  最后一种总线叫作控制总线，用来发送和接收关键信号，比如后面我们会学到的中断信号，还有设备复位、就绪等信号，都是通过控制总线传输。同样的，CPU 需要对这些信号进行响应，这也需要控制总线。

* 输出、输出设备

  输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。如果输入设备、输出设备想要和 CPU 进行交互，比如说用户按键需要 CPU 响应，这时候就需要用到控制总线。



**程序在计算机中的执行过程**

* 首先，CPU 读取 PC 指针指向的指令，将它导入指令寄存器。具体来说，完成读取指令这件事情有 3 个步骤：

  步骤 1：CPU 的控制单元操作地址总线指定需要访问的内存地址（简单理解，就是把 PC 指针中的值拷贝到地址总线中）。

  步骤 2：CPU 通知内存设备准备数据（内存设备准备好了，就通过数据总线将数据传送给 CPU）。

  步骤 3：CPU 收到内存传来的数据后，将这个数据存入指令寄存器。

  完成以上 3 步，CPU 成功读取了 PC 指针指向指令，存入了指令寄存器。

* CPU分析指令寄存器中的指令，确定指令的类型和参数。

* 如果是计算类型的指令，那么就交给逻辑运算单元计算；如果是存储类型的指令，那么由控制单元执行。

* PC指针自增，并准备获取下一条指令。

  比如在 32 位的机器上，指令是 32 位 4 个字节，需要 4 个内存地址存储，因此 PC 指针会自增 4。



回到上面的问题：

* 如果说的是 64 位宽 CPU，那么有 2 个优势：

  优势 1：64 位 CPU 可以执行更大数字的运算，这个优势在普通应用上不明显，但是对于数值计算较多的应用就非常明显。

  优势 2：64 位 CPU 可以寻址更大的内存空间

* 如果 32 位/64 位说的是程序，那么说的是指令是 64 位还是 32 位的。32 位指令在 64 位机器上执行，困难不大，可以兼容。 如果是 64 位指令，在 32 位机器上执行就困难了。因为 32 位指令在 64 位机器执行的时候，需要的是一套兼容机制；但是 64 位指令在 32 位机器上执行，32 位的寄存器都存不下指令的参数。

* 操作系统也是一种程序，如果是 64 位操作系统，也就是操作系统中程序的指令都是 64 位指令，因此不能安装在 32 位机器上。



#### 构建复杂的程序：将一个递归函数转成非递归函数的通用方法

* 一道比较有意思的面试题，不支持递归的程序语言如何实现递归程序

  这道题，该怎么回答呢，其实就是考察函数调用和返回的一个过程。

  首先，是通过压栈和出栈，参数开始压栈，然后返回地址压栈，然后参数出栈并计算出结果作为返回值入栈，再回到函数调用的地方。

  所以这道题的回答思路应该是这样的：

  1：我们需要用到一个栈（其实用数组就可以）。

  2：我们还需要一个栈指针，支持寄存器的编程语言能够直接用寄存器；而不支持直接用寄存器的编程语言，比如 java，我们可以用一个变量。

  3：然后我们可以实现压栈、出栈的操作，并按照:函数调用方法操作我们的栈。



这面这道题的白板面试题：**假设你使用的程序语言不支持递归程序，如果要求用栈来模拟下面这个斐波那契求第n项的程序，应该如何转换成等价的基于栈的非递归实现？**

```java
int fib(int n) {
 if(n == 1 || n == 2) {
     return n;
 }
  return 
      fib(n-1) + fib(n-2)
}

public int stack(int n) {
        Stack<Integer> stack = new Stack<>();
        stack.push(1);
        stack.push(1);

        int k = 3;
        while (k <= n) {
            Integer f1 = stack.pop();
            Integer f2 = stack.pop();

            Integer next = f1 + f2;
            stack.push(next);
            stack.push(f2);
        }

        stack.pop();
        return stack.pop();
    }
```




####  存储器分级：L1 Cache 比内存和 SSD 快多少倍？

首先，要了解缓存，寄存器，L1,L2,L3，内存，SSD

* 寄存器的数量通常在几十到几百之间，每个寄存器可以用来存储一定字节（byte）的数据。比如：

  32 位 CPU 中大多数寄存器可以存储 4 个字节；

  64 位 CPU 中大多数寄存器可以存储 8 个字节。

  寄存机的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写。比如一条要在 4 个周期内完成的指令，除了读写寄存器，还需要解码指令、控制指令执行和计算。如果寄存器的速度太慢，那 4 个周期就可能无法完成这条指令了。

* L1- 缓存在 CPU 中，相比寄存器，虽然它的位置距离 CPU 核心更远，但造价更低。通常 L1-Cache 大小在几十 Kb 到几百 Kb 不等，读写速度在 2～4 个 CPU 时钟周期。

* L2- 缓存也在 CPU 中，位置比 L1- 缓存距离 CPU 核心更远。它的大小比 L1-Cache 更大，具体大小要看 CPU 型号，有 2M 的，也有更小或者更大的，速度在 10～20 个 CPU 周期。

* L3- 缓存同样在 CPU 中，位置比 L2- 缓存距离 CPU 核心更远。大小通常比 L2-Cache 更大，读写速度在 20-60 个 CPU 周期。L3 缓存大小也是看型号的，比如 i9 CPU 有 512K L1 Cache；有 2MB L2 Cache； 有16MB L3 Cache。

* 内存的主要材料是半导体硅，是插在主板上工作的。因为它的位置距离 CPU 有一段距离，所以需要用总线和 CPU 连接。因为内存有了独立的空间，所以体积更大，造价也比上面提到的存储器低得多。现在有的个人电脑上的内存是 16G，但有些服务器的内存可以到几个 T。内存速度大概在 200～300 个 CPU 周期之间。

* SSD 也叫固态硬盘，结构和内存类似，但是它的优点在于断电后数据还在。内存、寄存器、缓存断电后数据就消失了。内存的读写速度比 SSD 大概快 10~1000 倍。以前还有一种物理读写的磁盘，我们也叫作硬盘，它的速度比内存慢 100W 倍左右。因为它的速度太慢，现在已经逐渐被 SSD 替代。

回到上面问题

因为内存比 SSD 快 10~1000 倍，L1 Cache 比内存快 100 倍左右。因此 L1 Cache 比 SSD 快了 1000~10000 倍。

这个问题告诉我们，不同的存储器之间性能差距很大，我们写程序的时候应该尽可能使用 CPU 缓存。



**问题**

假设有一个二维数组，总共有 1M 个条目，如果我们要遍历这个二维数组，应该逐行遍历还是逐列遍历？

读取数组的元素时，他会将和他连在一起的若干元素（块数据）都读入缓存中，而在遍历后续的数据时将直接命中缓存，大大减少了从内存读取次数，而二维数组中的列数据在内存上往往是不连续的，因此如果是按列遍历很难命中缓存，将不断的从内存读取数据，速度低。





### Linux指令



#### 目录结构和文件管理指令



* 什么是Shell

  Shell 把我们输入的指令，传递给操作系统去执行，所以 Shell 是一个命令行的用户界面。

* 文件的增删改查

  **增加**

  最常见的是 touch，如创建一个a.txt文件 touch a.txt，这个指令本来是用来更改文件的时间戳，但是如果文件不存在的话，会帮忙创建一个空的文件。

  增加目录：makdir

  **查看**

  ls   ls -l 

  **删除**

  删除指令 rm ，比如删除一个文件 rm a.txt, 如果删除一个目录 hello ,rm hello 的话是不行的，删除目录需要递归的删除，所以要增加一个可选项 **rm hello -r**。

  接下来我们尝试在 hello 目录下新增一个文件，比如相对路径是hello/world/os.txt。需要先创建 hello/world 目录。这种情况会用到mkdir的-p参数，这个参数控制mkdir当发现目标目录的父级目录不存在的时候会递归的创建。**mkdir -p hello/world**

  **修改**

  如果需要修改一个文件，可以使用nano或者vi编辑器。类似的工具还有很多，但是nano和vi一般是linux自带的。

  **查阅文件内容**

  当文件较小时，比如一个配置文件，想要快速浏览这个文件，可以用cat指令。cat 指令帮助我们快速查看/etc/hosts文件，cat /ect/hosts

  如果用cat查看大文件，比如一个线上的日志文件，因为动辄有几个 G，控制台打印出所有的内容就要非常久，而且刷屏显示看不到东西。

  而且如果在线上进行查看大文件的操作，会带来不必要的麻烦：

  首先因为我们需要把文件拷贝到输入输出流，这需要花费很长时间，这个过程会占用机器资源；

  其次，本身文件会读取到内存中，这时内存被大量占用，很危险，这可能导致其他应用内存不足。因此我们需要一些不用加载整个文件，就能查看文件内容的指令。

  **more 和 less 有差不多的功能**

  

  **head和tail**是一组，它们用来读取一个文件的头部 N 行或者尾部 N 行。比如一个线上的大日志文件，当线上出了 bug，服务暂停的时候，我们就可以用**tail -n 1000**去查看最后的 1000 行日志文件，寻找导致服务异常的原因。

  

  有时候你需要查看一个指定ip的nginx日志，或者查看一段时间内的nginx日志。如果不想用less和more进入文件中去查看，就可以用grep命令

  grep 这个词，我们分成三段来看，是 g|re|p。

  g 就是 global，全局；

  re 就是 regular expression，正则表达式；

  p 就是 pattern，模式。

  举个例子：比如我们想查看一个ip相关的日志：grep 192.168.10.10 logs.txt

  **查找文件**

   比如我们如果想要查找所有.txt 扩展名的文件，可以使用find / -iname "*.txt"，-iname这个参数是用来匹配查找的，i 字母代表忽略大小写，这里也可以用-name替代。

  

  **面试题如下：请你说说rm / -rf的作用？**

  /是文件系统根目录；

  rm是删除指令；

  -r是 recursive（递归）；

  -f是 force（强制），遇到只读文件也不提示，直接删除。

  所以rm -rf /就是删除整个文件系统上的所有文件，而且不用给用户提示。

  

  **文件系统中所有以包含std字符串且以.h扩展名结尾的文件。**

  find /  -name “std”



#### 进程、重定向和管道指令：xargs指令的作用是

##### 进程

应用的可执行文件是放在文件系统里，把可执文件启动，就会在操作系统里(具体来说是内存中)创建一个应用的副本，这个 副本就是进程。

想必，在面试的时候，经常会遇到这么一个问题，什么是进程？

进程是应用执行的副本，而不要回到进程是操作系统分配资源的最小单位，前者是定义，后者是作用

