---
layout:     post
title:      技术知识大全
subtitle:   日常知识点记录。
date:       2019-03-08
author:     tryingpfq
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - 知识大全
---

> 记录学习中遇到的知识点，或者日常记录一些碎片化知识点。

* [基础知识](#基础知识)
* [集合](#集合)
* [IO](#IO)
* [并发](#并发)
* [JVM](#Jvm)
* [调优](#调优)
* [网络知识](#网络知识)
* [算法](#算法)
* [框架](#框架)
* [分布式](#分布式)
* [大数据](#大数据)
* [数据库](#数据库)
* [字符编码和字符集](#字符编码和字符集)
* [脚本语言](#脚本语言)
* [游戏相关](#游戏相关)
* [经典博客]([http://jm.taobao.org/2018/06/13/%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%EF%BC%9F/](http://jm.taobao.org/2018/06/13/做服务发现？/))
* [其他](#其他)

### 基础知识

* SPI 技术 这个东西用的地方还是比较多的，下面简单说一下吧。[可参考博客](https://juejin.im/post/5af952fdf265da0b9e652de3)

  就是服务的提供是通过动态加载的，需要的时候才去进行加载，并且是通过配置来进行加载

  * 比如数据库驱动，对于不同的数据库，驱动应该是不同的，那你有没有想过，DriverManager是如何获得某确定驱动的呢。我们在运用Class.forName("com.mysql.jdbc.Driver")加载mysql驱动后，就会执行其中的静态代码把driver注册到DriverManager中，以便后续的使用。但Java  SPI 是会把所有的加载出来。
  * Dubbo中也使用了SPI [duboo SPI](http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html)，基于Key-Value形式
  * 

* new String("a") 和 new String("a").intern()，这个和字符串常量池中的对象和堆中对象创建相关，要彻底搞懂就必须对底层机制和源码要了解。[参考美团博客](https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html)

* 内部类和匿名内部类与外部的引用问题

  ```java
  public class InnerClassDemo {
  
      public static void main(String[] args) {
          Player player = new Player();
          new InnerClassDemo().innerClass(player);
          player.playeDoInner();//在player中，这个内部类调用了外部类outMethod()
          /*
          * public void playeDoInner(){
          	myInnerClass.doInner();//有想过这里是怎么调用的吗？(1)
          */
      }
  
  
      public void innerClass(Player player) {
          //在这里创建了一个内部类
          player.setMyInnerClass(new MyInnerClass());
      }
  
      public void outMethod(){
          System.err.println("outMethod");
      }
  
  	//内部类
      public class MyInnerClass{
          public void doInner(){
              outMethod();
          }
      }
  }
  ```

  问题（1）,这里需要看一下字节码的反编译，就能发现，在该路径下，会创建一个内部列InnerClassDemo$MyInnerClass.class,在构造方法中，可以看到，会对持有对外部类的引用。

  ```java
   public InnerClassDemo$MyInnerClass(InnerClassDemo this$0) {
          this.this$0 = this$0;
      }
  
      public void doInner() {
          this.this$0.outMethod();
      }
  ```

  **非静态内部类，是不可以在外部类以外实例化的。所以如果是静态内部类的话，也不需要持有对外部的引用。**

  再来看下匿名内部类

  ```java
    
  public static void hideInnerClass(Player player,List<String> message) {
        player.addExecutor(new IExecutor() {//传入一个匿名内部类
            @Override
            public void executor(Player player) {
                System.err.println(message);//有想过这个message会怎么传入的吗
            }
        });
      }
  ```

  问题（2）,这里也是在创建一个这个匿名内部类的时候，会在构造的时候传入。所以在用的时候要注意，如果传入的是一个对象，外面和内部类中是同一份引用

  ```java
  
  final class InnerClassDemo$1 implements IExecutor {
      InnerClassDemo$1(List var1) {
          this.val$message = var1;
      }
  
      public void executor(Player player) {
          System.err.println(this.val$message);
      }
  }	
  ```

  如果使用lambda表达式，也会去创建一个内部类的。

  **联想到另一个问题**

  就是我们在实例方法，经常可以使用this.file 来进行赋值，有想过这个this是怎么来的吗？其实对于每个`非静态`方法，默认的第一个参数是对象本身this。

  

* 动态修改或者增强字节码  [博客](https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html)

  主要有三种方式：ASM 和 javassist ,但是这两个只能在类加载之前才能生效，不然会报重复loadClass错

  Instrument是JVM提供的一个可以修改已加载类的类库，专门为Java语言编写的插桩服务提供支持




* java8 新特性,函数式编程

  * lambda表达式

  * 方法引用

  * stream

    ```java
    //将文件转为stream 觉得这个应该是挺实用的
    try (Stream<String> lines = Files.lines(Paths.get("/path/to/file.txt"))) {
        ...
    }
    ```

  * Optional

* 如何实现一个实现了Serializable接口的单例

  ```java
  public class Singleton implements Serializable{ 
      private final static Singleton singleInstance = new Singleton(); 
      private Singleton(){} public static Singleton getInstance(){
          return singleInstance;
      }
  }
  
  ```

  看到这个问题我是有点蒙蔽的，所以肯定是和序列化的时候有关，序列化中的readObject会通过反射，调用没有参数的构造方法创建一个新的对象。

  那怎么解决呢？

  们可以在被序列化类中重写readResolve方法。

  private Object readResolve(){
      return singleInstance;
  }
  java.io.ObjectStreamClass#invokeReadResolve

  readResolve：反序列化时替换反序列化出的对象，反序列化出来的对象被立即丢弃。此方法在readeObject后调用

  那如果是需要序列化的时候，会有这样的方法吗：writeReplace：在序列化时，会先调用此方法

* 

### 集合

  * concurrentHashMap 的死循环问题
  
    下面看下这段代码,这个map会一直在方法computeIfAbsent中循环。
  
    ~~~java
    private static Map<String, Integer> map = new ConcurrentHashMap<>();
        public static void main(String[] args) {
            map.computeIfAbsent("AaAa", k -> {
                return  map.put("BBBB",42);
            });
            System.out.println(map);
        }
    ~~~
  
    可以把堆栈dump出来看一下，就可以看到一个死锁的地方。
    ![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-question-1.png?raw=true)
    很明显可以看到是在ConcurrrentHashMap中的1660行这里发生了死循环，具体原因可以看下源码和网上一些博客
    参考[博客](https://cloud.tencent.com/developer/article/1533786)

* 容器中的拷贝是浅拷贝的，什么意思呢，假如有一个listData,然后我们拷贝一份的时候，如果是这样调用的话copy = new  ArrayList<>(listData),这两个list持有的对象的相同的。

* java中的重载方法是根据参数来判断的，但如果我们参数是一个多态类型，也就是下面这样

  ```java
  class Exe{
      void do(A a);
  	void do(B b);
  }
  A extends Base;
  B extends Base;
  
  //下面代码会报错
  Base base = get();
  exe.do(base);//这里是会报错的，为什么呢，重载方法必须要在编译的时候就确定参数具体的实际类型 (1)
  
  //如果在Exe中添加一根重载方法
  void do(Base base);
  //那么上面就不会报错，编译的时候就能确定调用 do(Base base) 这个方法
  ```

  为什么呢，这个java语言特性有关，java是Single Dispatch，如果是Double Dispatch这里就不会报错。Single Dispatch 之所以称为“Single”，是因为执行哪个对象的哪个方法，只跟“对象”的运行时类型有关。Double Dispatch 之所以称为“Double”，是因为执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关。

  那么如何解决上面这个问题呢，其实就要用到访问者模式

  不过怎么样，我觉得解决思路都是要处理上面(1)这个地方，可以通过base.accept(),然后在对应accept中，去调用do(this)方法就解决。 

  当然也可以用工厂模式去解决呢

  [参考](https://blog.csdn.net/yqj2065/article/details/38960149?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2)

  [极客时间设计模式](https://time.geekbang.org/column/article/222762)

* 

### IO

* 零拷贝

  其实零拷贝，不是真正的零拷贝，但该怎么去理解呢？假如我读取一个静态资源文件，然后把内容发送出去。

  传统的是怎样的呢，首先是read()文件方法，然后由用户态切换到内核空间，内核空间把文件内容读取拷贝(1)到内核缓冲区，read读完后，会切换回用户进程空间，此时文件内容是被拷贝(2)回用户态缓冲区，接着需要send()的话，用户态又需要切换到内核态，并把数据拷贝(3)到内核空间缓冲区（这个缓冲区是与目标套接字相关联的缓冲区），send()方法返回又需要切换到用户态，DMA引擎将数据从内核缓冲区传输到协议引擎缓冲区时，第四次拷贝是独立且异步的。这里涉及了四次切换和四次拷贝。

  其实如果想想，数据是否可以不用拷贝回用户态，`上面的2 3拷贝，应用程序除了缓存数据后，再将数据传回套接字缓冲区，并没有做任何事情`,如果直接操作内核空间的缓冲区，是不是就可以省了。

  那现在说的零拷贝我觉得应该是这样的：

  经过`transgerTo`方法调用触发DMA引擎将文件上下文信息拷贝到内核读缓冲区，接着内核将数据从内核缓冲区拷贝到与外出套接字相关联的缓冲区(这个地方有改进)。

  DMA引擎将数据从内核套接字缓冲区传输到协议引擎（第三次数据拷贝）。

  但是好像听说上面可以做一些改进，就是内核不会将数据拷贝到套接字相关联缓冲区，而是只拷贝数据的描述符（数据位置和长度等）拷贝，DMA 引擎直接将数据从内核缓冲区拷贝到协议引擎，这样减少了最后一次需要消耗CPU的拷贝操作。

  ![](https://github.com/tryingpfq/tryingpfq.github.io/blob/master/picture/bg-index1.jpg?raw=true)

  [参考](https://www.jianshu.com/p/82d7269521a3)

  

* Socket

  今天遇到一个疑问，就是关于BIO通信，不知道为什么每次socket只能发送一次数据。

  ```java
  //客户端代码
  while (true) {
      //如果把这样代码移到while外面是只会发送一次的，后面close不关闭。
      //也就是说一个socket只能发送一次。
      Socket client = new Socket("localhost", 8080);	
      OutputStream os = client.getOutputStream();
      String name = UUID.randomUUID().toString();
      os.write(name.getBytes());
      os.close();
      client.close();
  }
  //服务端代码
  while(true){
      try {
          Socket client = server.accept();//等待客户端连接，阻塞方法    (1)
          //拿到输入流，也就是乡村公路
          InputStream is = client.getInputStream();
          //缓冲区，数组而已
          byte [] buff = new byte[1024];
          int len = is.read(buff);
          //只要一直有数据写入，len就会一直大于0
          if(len > 0){
              String msg = new String(buff,0,len);
              System.out.println("收到" + msg);
          }
      } catch (Exception e) {
      }
  }
  //while中代码都是在另一条线程中，而且main线程外面也没关闭呀
  
  ```

  上面这段理解肯定是错误的，为什么会出现这种疑问呢

  当客户端第一次连接的时候，代码(1)出会唤醒，往下执行，但后面如果没有新的客户端记性连接，就会一直阻塞在这里。后面得不到执行，所以客户端发送的数据就无法接收。BIO当然也是可以用同一条连接来回发送数据的。**这里有没有想到会引起一个什么问题，没有新的连接的话这里是不是会一直阻塞。**

  下面看下简单的BIO客户端和服务端交互代码实现：

  ```java
  //客户端
  public static void main(String[] args) throws IOException, InterruptedException {
  		final Socket client = new Socket("localhost", 8080);
  			//写线程
  			new Thread(() -> {
  				try{
  					//latch.await();
  					OutputStream outputStream = client.getOutputStream();
  					byte[] buffer = new byte[1024];
  					int n;
  					System.out.println("客户端请输入：");
  					while ((n = System.in.read(buffer)) > 0) {
  						outputStream.write(buffer, 0, n);
  					}
  				}catch(Exception e){
  				}
  			}).start();
  			//读线程
  			new Thread(() -> {
  				try {
  					InputStream in = client.getInputStream();
  					byte[] buffer = new byte[1024];
  					int n;
  					while ((n = in.read(buffer)) > 0) {
  						//
  						System.out.print("客户端收到：");
  						System.out.write(buffer, 0, n);
  						System.out.println();
  						System.out.println("客户端请输入：");
  					}
  				} catch (IOException e) {
  					e.printStackTrace();
  				}
  
  			}).start();
  			Thread.sleep(Integer.MAX_VALUE);
  	}
  
  //Server
  ServerSocket server;
  	//服务器
  	public BIOServer(int port){
  		try {
  			server = new ServerSocket(port);
  			System.out.println("BIO服务已启动，监听端口是：" + port);
  		} catch (IOException e) {
  			e.printStackTrace();
  		}
  	}
  	
  	/**
  	 * 开始监听，并处理逻辑
  	 * @throws IOException 
  	 */
  	public void listener() throws IOException{
  		Socket client = null;//等待客户端连接，阻塞方法
  		try {
  			client = server.accept();
  		} catch (IOException e) {
  			e.printStackTrace();
  		}
  		Socket finalClient = client;
  
  		new Thread(() -> {
  			int i = 0;
  			while(true){
  				try {
  					//拿到输入流，也就是乡村公路
  					InputStream is = finalClient.getInputStream();
  					//缓冲区，数组而已
  					byte [] buff = new byte[1024];
  					int len = is.read(buff);	//如果没有数据这里会阻塞在这里的
  					if(len > 0){
  						String msg = new String(buff,0,len);
  						System.out.println("服务端收到:" + msg);
  					}
  					OutputStream outputStream = finalClient.getOutputStream();
  					String response = "serverResp_" + i;
  					outputStream.write(response.getBytes());
  					i++;
  				} catch (Exception e) {
  				}
  			}
  		}).start();
  	}
  	
  	public static void main(String[] args) throws IOException {
  		new BIOServer(8080).listener();
  		System.in.read();
  	}
  ```

  上面代码就可以看到一个交互的过程，只要这个连接还在，就能保持通信的。

  上面说到阻塞的问题(accept 和 read)，自然会有NIO了，客户端是SocketChannel，服务端ServerSocketChannel。

  我觉得为什么叫做非阻塞呢，因为NIO是不在用accept方法来监听客户端，而是注册了Selector，我们可以直接查看selector中是否有事件，而且应该是有事件的话，selector会收到通知。还有一个地方，就是BIO在连接后，在read()方法如果没有可读的数据 也是会阻塞的(所以是不是经常用一条线程处理一个客户端，这样就不易于控制，不知道要多少线程，还有线程上下文切换回比较平凡)，而NIO是基于通道，每个通道都有缓冲区的。

  [美团技术博客](https://tech.meituan.com/2016/11/04/nio.html)

* 

### 并发
   * 1：long型变量在32位机上读写会出现并发问题吗？
   
       这其实是一个原子问题，因为long型是64位，如果是32位机的话，则在cpu上的写操作要分成2次，一次写高32位，
       另一次写低32位。在单核CPU的场景下，同一时刻只有一个线程执行，会禁止CPU中断，也就是禁止了线程的切换，所以这两次
       写是具有原子性的，不会出现问题。但在多核场景下，同一时刻，可能有多个线程在执行，如果两个线程同时在写变量的高32位，
       就会出现诡异的问题了。
       
   * 2：若有一个共享变量abc，在一个线程里设置了abc = 3,有哪些办法可以让其他线程能够看到abc = 3？
      这个问题可以从java内存模型规范中去解答。
        * 1：可以通过volatile保证共享变量的可见性。
        * 2：使用原则变量。
        * 3：对abc写的时候，加锁。
        * 4：private修饰，通过set()方法修改，并通过get()方法获得。(这个方法保留)
      
   * 3：看一下下面这段代码能解决并发问题吗？
   ```java
        class SafeCalc {
          long value = 0L;
          long get() {
            synchronized (new Object()) {
              return value;
            }
          }
          void addOne() {
            synchronized (new Object()) {
              value += 1;
            }
          }
        }
   ```
   很明显肯定是不可以的，两次都new了，锁的不是同一对象。加锁本质就是在要锁的对象的对象头中写入当前线程ID，new Object
   每次在内存中都是新的对象，所以加锁无效。
   其实经过JVM逃逸分析，这个sync代码会直接被优化掉。运行时的代码是无锁的。

   * 4：看下这段代码，如果锁住的不是lalLock对象，而是this.balance,这样可行吗？
     ```java
        class Account {
          // 锁：保护账户余额
          private final Object balLock = new Object();
          // 账户余额  
          private Integer balance;
         
          // 取款
          void withdraw(Integer amt) {
            synchronized(balLock) {
              if (this.balance > amt){
                this.balance -= amt;
              }
            }
          } 
          // 查看余额
          Integer getBalance() {
            synchronized(balLock) {
              return balance;
            }
          }
        }
     ```
      其实我开始以为是可行的，先看看自己错误理解呀，以为锁住字段就可以了，而且之前还不知道，锁的是对象，假如int就不行了。
      为什么锁balock是可以了，因为是一个不可变对象，多个线程拿到balock是一样的，故这样加锁是可以的。如果锁住的是this.balance是不可的，
      这是一个可变对象，当有线程对其修改后，这个字段就换成了一个先的对象（注意，这个Account对象是没改变），此时就出现了多个锁，锁同一资源。
      注意，锁对象是不能用可变对象的。当然问题中，说Integer -128到127是缓存的，如果在这个区间段，是不是可以锁呢，你觉得呢，肯定不可以呀，你想
      一下，在这个区间段有多少代码在使用，这不要卡死吗。
   
   * 5：开启10000个线程，每个线程给员工表的money字段【初始值是0】加1，没有使用悲观锁和乐观锁，但是在业务层方法上加了synchronized关键字，
      问题是代码执行完毕后数据库中的money 字段不是10000，而是小于10000 问题出在哪里？
      这个问题的解答可以参考[开源中国](https://my.oschina.net/u/3777556/blog/3011167)
   
   * 6：线程中断。(当某个线程被其他线程中断后，其他线程在睡眠或者阻塞的时候可以检测到异常)。看下面这段代码会有睡眠问题
```java
    Thread th = Thread.currentThread();
    while(true) {
      if(th.isInterrupted()) {
        break;
      }
      // 省略业务代码无数
      try {
        Thread.sleep(100);
      }catch (InterruptedException e){
        e.printStackTrace();
      }
    }
```
本意是通过th.isInterrupted()来检测线程是否被中断，如果中断了就退出循环。当其他线程通过调用th.interrupt()来中断th线程时，
会设置th线程的中断标志位，从而th.isInterrupted()返回true，退出while循环。

这看上去是没什么问题，实际上几乎起不了作用，这段代码大部分时间都是阻塞在sleep上，当其他线程通过调用th.interrupt()来中断th
线程时，大概率会触发InterruptedException异常，**在触发InterruptedException异常的同时，JVM会把线程的中断标志位清除，所以这个
时候th.isInterrupted()返回false。看正确的代码：
```java
try {
  Thread.sleep(100);
}catch(InterruptedException e){
  // 重新设置中断标志位
  th.interrupt();
}

```

   * 7:如何终止线程
      从线程的转换，可以知道，可以直接用stop()方法，但这个方法好像很早就已近被抛弃了。
      一个线程要自动转为终止状态，那么必须是从运行->终止。一般正确的终止线程，分为两个
      步骤，设置标志位isTerminaged,以后就是中断操作Thread.currentThread().interrupt()

### JVM

> JVM是比较难的一个东西，但我觉得也是最基础的东西，毕竟一行源代码是如何进行执行的过程，自己还是要去了解，而且现在网上也很多博客，其实看过一些，你会发现很少有些的比较正确的。
>
> 



### 调优

#### JVM调优



#### 数据库调优



### 算法

​	**练习网址** [leetcode](https://leetcode.com/)

   * 今天突然想到一个关于数组的问题，就是为什么数据初始位置从0开始？
     
        首先，可能是历史原因问题，因为C语言一开始就是从零开始，后来一些高级语言，考虑学习成本，就沿用了。
        
        但从分析上来说可能是另一个原因：
        >假设数据int[] a,那么a是数组的首位置，a[0]也就是偏移量为0的地址，也就是首地址，如果要
        查找a[k]，即编译量为k的地址的值,根据公式：addr = base_addr(a) + k * type_size(int 4字节)。
        如果从1开始会有什么问题呢，就要有（k-1）操作，多了一次cpu指令。
        



* 假设现在我们有一个包含 10 亿个搜索关键词的日志文件，如何能快速获取到热门榜 Top 10 的搜索关键词呢？(这个可以用堆来解决)

  这里主要是有关堆的应用，上面只是抛出一个问题。堆主要应用就，1：一个是优先级队列，想到定时器中任务就可以是一个堆；2：求TOP k问题；3：求中位数

  **求TOP k 问题的思路**

  加入在n个数据中，找出前k个大小的数据：那么可以维护一个k大小的小顶堆，顺序遍历n个数据，如果比堆顶要大，就把堆顶元素删除，然后把这个元素插入到堆中。遍历完后，这个堆就是前k大小的元素。
  
* 一致性hash算法

  这个什么时候会用到呢，一般是在缓存用的比价多，还有分库分表，分布式中，如果节点发生变化，用普通的hash算法是不行的，会改变原来缓存映射，所以就需要用到一致性hash算法。我个人觉得吧，原理就是hash运算的时候，模数固定不变呀。

  [参考-掘金](https://juejin.im/post/5ae1476ef265da0b8d419ef2)

* 字符串匹配，其实这个是比较难的，如果是粗暴的倒是比较简单，逐个字符进行比较就好，比如BF 算法和 RK这两个字符串匹配算法还是比较容易理解的，但对于**BM（Boyer-Moore）算法**就比较难懂一些，其这个算法核心还是通过一些策略来减少字符串的比对。

  

* 字典树

  有没有想过一个问题，比如百度和Google搜索引擎，输入的时候，就会有提示(但实际上并没这么简单，比如当我们出入错一个字母，还是可以正常提示的)，这个是怎么实现的。其实就是基于字段树(Trie)。还有输入法和编辑器的自动补全功能。

  Trie的查询效率是比较高的，假如要查询的字符串的长度为k，那么时间复杂度为o(K) ,但是当时间复杂度低的时候，就可能比较浪费空间，确实如此，因为每个节点存储的信息比较多，而且可能很多浪费的空间。‘

  

* 贪心算法



### 框架

* Spring

  * AOP

    spring aop是基于动态代理：JDK(这个只能对接口)，所有就有了CGLIB(目标类的子类)

    Q:那一般我们到底用哪种呢，处理上面基于接口的限制考虑

    A:**如果是单例的我们最好使用CGLib代理，如果是多例的我们最好使用JDK代理**

    W:DK在创建代理对象时的性能要高于CGLib代理，而生成代理对象的运行性能却比CGLib的低,

    如果是单例的代理，推荐使用CGLib。

  * 

* Log4j

* Tomcat

* Maven



### 分布式

#### zookeeper

* 为什么不建议用zk做服务发现，参考下方博客

#### dubbo

* 幂等性如何保证

### 大数据

* hadoop

  * mapReduce框架

    看下mapduce的使用，用来统计文本某个单词的出现次数，话不多说，直接看代码

    ~~~java
    public class WCMapper extends Mapper<LongWritable, Text, Text,IntWritable> {
        @Override
        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {
            //每一行的数据
            String line = value.toString();
    
            String[] words = line.split(",");
    
            //写入到context中去进行reduce
            for (String word : words) {
                context.write(new Text(word), new IntWritable(1));
            }
    
        }
    }
    
    public class WCReduce extends Reducer<Text, IntWritable, Text, Text> {
        /**
         * map处理之后，传过来的是一个value集合
         */
        @Override
        protected void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {
            int count = 0;
    
            // value 传过来的集合
            for (IntWritable value : values) {
                count += value.get();
            }
            context.write(key, new Text(count + ""));
            
        }
    }
    //启动方法
    public static void main(String[] args) throws IOException {
    
            //首先要描述一个作业
            Job job = Job.getInstance(new Configuration());
    
            //设置mapper类型
            job.setMapperClass(WCMapper.class);
            job.setMapOutputKeyClass(Text.class);
            job.setMapOutputValueClass(IntWritable.class);
    
            //设置reduce类型
            job.setReducerClass(WCReduce.class);
            job.setOutputKeyClass(Text.class);
            job.setOutputValueClass(Text.class);
    
            //指定原始数据存放在哪里
            //参数1：里面是对哪个参数进行指定
            //参数2：文件在哪个路径下,这个路径下的所有文件都会去读的
            FileInputFormat.setInputPaths(job, new Path("input"));
    
            //指定处理结果的数据存放路径
            FileOutputFormat.setOutputPath(job, new Path("out"));
    
            //提交
            int isok = 0;
            try {
                isok = job.waitForCompletion(true)?0:-1;
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
            System.exit(isok);
    ~~~

    上面就一个简单的应用，以后等具体了解的时候再去看吧[参考](https://blog.csdn.net/qq_35078688/article/details/83240661?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)

* 

* 



### 网络知识

   * 1：为什么有了IP地址还需要MAC地址，有了唯一的MAC地址还需要IP地址？
  
      因为对于用户所在的终端（计算机），分配的IP地址是会随时变化的，而且对于各个局域网中，IP可能是相同的。
      为何不可以通过唯一的MAC地址来找到目标终端呢，MAC地址是在网卡中的，由厂商规定。可以举个身份证的例子来
      解释这个问题，身份证号是可以唯一标识一个人的，但通过身份证号是不能找到这个人在何处，首先，前六位是可以确定
      县地址，但知道县也不能找到这个人，应为现居地和出身地不一定相同。同样MAC地址中，有标识知道厂商。所以网络中需要
      MAC地址和IP地址，MAC地址好比身份证号，IP地址好比现居地。如果真的用MAC地址来解决这个问题，那得要一个多大的MAC
      地址表，而且MAC地址是同ARP广播寻找，那可想想网络中的ARP广播风暴。IPv6是可以解决这种问题的，但目前协议还是需要
      MAC的。
      
      记住IP地址是有定位功能，MAC地址是有唯一标识功能，所以两个必须一起合作寻找才能完成。当然，如果是在一个私网当中，
      是可以直接用MAC地址传输的。
      
      [参考-趣谈网络协议-第一讲]()
   * 2：怎么查找IP地址呢？

   相必都知道在windows中，可以用ipconfig,在linux 中可以用ifconfig ip addr(这两个命令有什么区别呢)，IP地址是如何来的呢 [参考-趣谈网络协议-第3讲]()



### 数据库



### 字符编码和字符集

对于字符来说，通常要用一个唯一的编码来标示，固然是一个二进制数字，当然标示的时候可能是16进制，但最后计算机还是只认识二进制。每种编码还是会有区别的，比如ASCII是用一个字节来标示，也就是可以标识256个字符从`00000000`到`11111111`，但世界上的字符并不止256个，所以出现多种编码方式，对于同一个二级制数字可能被解释成不同的字符。Unicode就可以唯一标识一个字符。

i.ASCII



ii.Unicode

​	Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，`U+0639`表示阿拉伯字母`Ain`，`U+0041`表示英语的大写字母`A`，`U+4E25`表示汉字`严`

​	Unicode编码则是采用双字节16位来进行编号，可编65536字符，基本上包含了世界上所有的语言字符，它也就成为了全世界一种通用的编码，而且用十六进制4位表示一个编码，非常简结直观。

​	想想，这种编码会不会存在一些问题，1：比如严字，需要的是两个字节来标识，那么计算机怎么知道是两个字节还是三个字节来标示一个符号呢，2：如果统一用四个字节来存储，那么问题就解决了，但是你相信一个因为字母，只需要只需要一个字节就够了，这样是不是很浪费空间呢。

iii UTF-N

​	基于Unicode编码出现的问题，就出现了UTF-8/16/32(都是Unicode的实现方式)，当然UTF-8是互联网用的UTF-8用的最广泛。那么UTF-8是如何边长的来决定呢，自然有自己的编码规则。

**java中的char到底占几个字符问题，一个char可以标示一个汉字吗**

在java中，char内置编码采用的是UTF-16，所以就是一两个字节为一个码点，因为部分特殊字符，可能两个字节无法存下，那么就需要两个char量存储，也就是四个字节了。看下下面这段代码情况。

~~~java
 //平时常见的汉字
        String str = "中";
        //str.length 就是char[]数组长度
        System.err.println(str.length());

        // Unicode编码 汉字扩展 '𠀀' 字
        String str1 = "\uD840\uDC00";
        System.err.println(str1.length());

        char[] array = new char[]{'\uD840', '\uDC00'};
        System.err.println(new String(array));

输出结果
1
2
𠀀
~~~

*需要注意的是*

> java里的char类型无论何时都是2字节的，字母'A'也不例外，只是在流中就不一定了，因为不同的编码方式有不同的规则。 unicode第一Plane总共有65536个空位，是16位的，占两个字节，因为java仅使用了unicode的第一个Plane，所以也是16位的。 从字符流中以某种字符编码读取读取字符时，会将流中的字节以某种字符编码的机内码规则进行解码，并转换为unicode的值存储到char类型变量中；向字符流以某种字符编码写入字符时，会将char类型的unicode码代表的字符以某种的字符编码的机内码规则进行编码，然后将编码后的字节写入到目标流中。

[java中char汉字占几个字符](https://www.cnblogs.com/nevermorewang/p/7808092.html)

[参考-阮一峰](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)

### 脚本语言

其实说到脚本语言，一般都是可以动态编译的，开发效率比价搞，可以嵌套到别的语言中，因为目前项目中就用到了Groovy脚本。

* groovy

  参考：[30分钟快速入门](https://www.cnblogs.com/amosli/p/3970810.html)  [Groovy快速入门](https://www.jianshu.com/p/e8dec95c4326)

* 



### 游戏相关

一些项目源码：

[永恒之塔开源服务器架构](https://github.com/Aion-server/Aion-unique) [天堂2](https://github.com/oonym/l2InterludeServer) 



### 经典博客

[阿里巴巴为什么不用 ZooKeeper 做服务发现]([http://jm.taobao.org/2018/06/13/%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%EF%BC%9F/](http://jm.taobao.org/2018/06/13/做服务发现？/))

[浅谈分布式幂等性](https://www.jianshu.com/p/475589f5cd7b)


### 其他

  * Log4j 日志系统是如何初始化和加载的
    这里只能断点看了，主要是LogManager这个类中的静态块，会到classpath下去读取相应的配置文件，和一些相应的初始化。
    
  * Maven是如何将工程目录下的java文件进行编译
  
  * SimpleDateFormat 和 DateTimeFormatter
    我们在使用SimpleDateFormat的使用，一般是定义为一个静态成员变量，但大家应该都知道，这个是线程
    不安全的，多个线程会共享这个format，所以一般我们是怎么处理的呢，使用ThreadLocal<T> 给每个线程
    拷贝一个副本，来解决下次安全问题，下面这个代码，应该代价都看过吧平时。
    ~~~java
    private static ThreadLocal<SimpleDateFormat> dateformat = 
    ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd HH:ss"))
    ~~~
    

   [参考](https://www.jianshu.com/p/b212afa16f1f)

* Pair 可以用来返回一个key 和 一个Value。



### 一些网址

[思否](https://segmentfault.com/)  [appach Issue ](https://issues.apache.org/jira/projects) [美团技术团队](https://tech.meituan.com/) [淘宝中间件技术团队博客](http://jm.taobao.org/)

